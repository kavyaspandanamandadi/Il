What is Infrastructure as Code(IaC)?
The idea behind infrastructure as code (IaC) is that you write and execute code to define, deploy, and update your infrastructure. Infrastructure as Code (IaC) is the management of infrastructure (networks, virtual machines, load balancers, and connection topology) in a descriptive model, using the same versioning as DevOps team uses for source code. Like the principle that the same source code generates the same binary, an IaC model generates the same environment every time it is applied. IaC is a key DevOps practice and is used in conjunction with continuous delivery.
Why infrastructure-as-code?
Infrastructure as Code evolved to solve the problem of environment drift in the release pipeline. Without IaC, teams must maintain the settings of individual deployment environments. Over time, each environment becomes a snowflake, that is, a unique configuration that cannot be reproduced automatically. Inconsistency among environments leads to issues during deployments. With snowflakes, administration and maintenance of infrastructure involves manual processes which were hard to track and contributed to errors.
A long time ago, in a data center far, far away, as sysadmins used to deploy infrastructure manually. Every server, every route table entry, every database configuration, and every load balancer was created and managed by hand. It was a dark and fearful age: fear of downtime, fear of accidental misconfiguration, fear of slow and fragile deployments, and fear of what would happen if the sysadmins fell to the dark side. we now have a better way to do things: Infrastructure-as-Code(IaC).
 Benefits of Infrastructure as a code:
•	You can automate your entire provisioning and deployment process, which makes it much faster and more reliable than any manual process.
•	You can represent the state of your infrastructure in source files that anyone can read rather than a sysadmin’s head.
•	You can store those source files in version control, which means the entire history of your infrastructure is now captured in the commit log, which you can use to debug problems, and if necessary, roll back to older versions.
•	You can validate each infrastructure change through code reviews and automated tests.
•	You can create reusable, documented, battle-tested infrastructure packages that make it easier to scale and evolve your infrastructure.

Advantages of IaC:
Idempotence is a principle of Infrastructure as Code. Idempotence is the property that a deployment command always sets the target environment into the same configuration, regardless of the environment’s starting state. Idempotency is achieved by either automatically configuring an existing target or by discarding the existing target and recreating a fresh environment.
Changing the Source (not Target): With IaC, teams make changes to the environment description and version the configuration model, which is typically in well-documented code formats such as JSON. The release pipeline executes the model to configure target environments. If the team needs to make changes, they edit the source, not the target.
Testing: Infrastructure as Code enables DevOps teams to test applications in production-like environments early in the development cycle. These teams expect to provision multiple test environments reliably and on demand. Infrastructure represented as code can also be validated and tested to prevent common deployment issues. At the same time, the cloud dynamically provisions and tears down environments based on IaC definitions.
Reusability: Teams who implement IaC can deliver stable environments rapidly and at scale. Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code. Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies. DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale.
What is Terraform?
Terraform is a cloud-agnostic tool (works for multiple cloud providers like Azure or AWS) which allows you to orchestrate your infrastructure via code. It’s a tool for building, changing, and versioning infrastructure safely and efficiently. Basically, you define the components or resources in your configuration file, tell it which provider to use, generate an execution plan prior to deployment, and then execute the build.

So why Terraform?
As the need to deploy cloud infrastructure grows, resource management becomes more complex. The ability to maintain the original design in check to avoid architectural drift across several live environments, while keeping open the possibility to add or remove resources as requirements evolve is a challenge faced by every DevOps team.
The benefit that Terraform provides is simple - it acts as middleware that orchestrates the management of Virtual Machines and other virtual resources on multiple cloud hosts, thus freeing the developer from having to manage different, constantly changing APIs when trying to manage a cloud infrastructure. Terraform is an open source library (written in GO language), that we interface with using a command line interface (CLI) and configuration files. The configuration files are in simple JSON format, and the instructions 'encoded' in the JSON payload can be specific to each host provider. The instructions in the payload are translated by Terraform as needed to manage virtual resources using the specific APIs of each cloud host. Terraform has basically has done the heavy lifting for us already, its open source, and its well maintained, so we really don't need to worry about it, 
Key features of terraform:
•	Infrastructure as Code – process of managing and provisioning infrastructure and configuration through high-level configuration syntax.
•	Execution Plans – shows what the deployment will do prior to doing anything. Helps avoids failed deployments.
•	Resource Graph – allows terraform to map out the resources and dependencies to deploy the infrastructure as efficiently as possible.
•	Change Automation – helps avoid human error while changes are orchestrated.

How I structure Terraform configurations
This is one of the best ways we like to structure Terraform configurations which can be used to manage medium and large infrastructures with resources span multiple AWS accounts (e.g., Development, QA, Staging, Production) and multiple regions.
Infrastructure review:
Resources are grouped into layers, where each layer consist only of:
•	Global resources (IAM, Cloudfront, Cloudtrail, Config, Route53 zones)
•	Regional resources (EC2, VPC, Codedeploy, Cloudformation)
Developer can interact with a single layer, which is identifiable by combination of arguments:
•	AWS account alias (PgrDev for example)
•	Region name (eu-west-1 for example)
•	Layer name (global, shared, Application for example)
Directory structure
 
 .
├── accounts
│   ├── company-dev
│   │   ├── application.eu-west-1.tfvars
│   │   ├── global.tfvars
│   │   └── shared.eu-west-1.tfvars
│   ├── company-cicd
│   │   ├── cicd.eu-west-1.tfvars
│   │   └── global.tfvars
│   ├── company-legacy
│   │   └── legacy.tfvars
│   ├── company-prod
│   │   ├── application.eu-west-1.tfvars
│   │   ├── global.tfvars
│   │   └── shared.eu-west-1.tfvars
│   └── company-staging
│       ├── application.eu-west-1.tfvars
│       ├── global.tfvars
│       └── shared.eu-west-1.tfvars
├── layers
│   ├── company-dev
│   │   ├── application
│   │   │   ├── main.tf
│   │   │   ├── output.tf
│   │   │   └── variables.tf
│   │   ├── global
│   │   │   ├── main.tf
│   │   │   ├── output.tf
│   │   │   └── variables.tf
│   │   └── shared
│   │       ├── main.tf
│   │       ├── output.tf
│   │       └── variables.tf
│   ├── company-infra
│   │   ├── cicd
│   │   │   ├── iam.tf
│   │   │   ├── main.tf
│   │   │   ├── output.tf
│   │   │   └── variables.tf
│   │   └── global -> ../../company-dev/global
│   ├── company-static
│   │   └── static
│   │       ├── main.tf
│   │       ├── output.tf
│   │       └── variables.tf
│   ├── company-prod
│   │   ├── application -> ../../company-staging/application
│   │   ├── global -> ../../company-staging/global
│   │   └── shared -> ../../company-staging/shared
│   └── company-staging
│       ├── application
│       │   ├── main.tf
│       │   ├── output.tf
│       │   └── variables.tf
│       ├── global
│       │   ├── main.tf
│       │   ├── output.tf
│       │   └── variables.tf
│       └── shared
│           ├── main.tf
│           ├── output.tf
│           └── variables.tf
├── modules
│   ├── application
│   │   ├── codedeploy.tf
│   │   ├── output.tf
│   │   └── variables.tf
│   ├── global
│   │   ├── cloudtrail.tf
│   │   ├── iam.tf
│   │   ├── main.tf
│   │   ├── output.tf
│   │   └── variables.tf
│   ├── shared
│   │   ├── bastion.tf
│   │   ├── networking.tf
│   │   ├── output.tf
│   │   ├── route53.tf
│   │   ├── variables.tf
│   │   └── vpc_peering.tf
│   └── typical_service
│       ├── codedeploy.tf
│       ├── output.tf
│       ├── service.tf
│       └── variables.tf
└── terraform.sh
 
 
Notes:

•	Accounts/{aws_alias}/*.tfvars -values
•	Layers/{aws_alias}/{layer_name}/*.tf- Terraform configurations. Normally it contains module  invocations and terraform _remote_state configurations to higher layers (global and shared).
•	Layers/Company-prod/* - is a symlink to layers/company-staging/* to reduce chance of configuration drift
•	Modules - Terraform modules (typically invoked from multiple AWS accounts with various values)
•	terraform.sh- Terraform wrapper script, which set correct working directory and load correct tfvars file
Pros
•	Easy to navigate infrastructure as code
•	Outputs of higher level layers are available as read-only values to layers below
•	Full set of Terraform features (commands and arguments) is supported
•	Versioned layers based on same tfvars can be implemented (blue-green deployment)
•	Very easy to integrate with CI pipeline
•	Locking is also implemented  
Cons
•	May be hard to limit permissions for Terraform users between state files inside one AWS account (all states files are readable by users in that account, by default)
